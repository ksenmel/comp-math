# Задача Дирихле для уравнения Пуассона
## Цель работы
1. Разобраться в параллельном алгоритме 11.6, предложенном в 11 главе книги В. П. Гергеля
   [“Высокопроизводительные вычисления для
   многоядерных многопроцессорных систем” (2010)](https://github.com/artjomjuferov/university/blob/master/Beljakova/Гергель%20В.П.%20Высокопроизводительные%20вычисления%20для%20многоядерных%20многопроцессорных%20систем%20(2010).pdf)
2. Реализовать этот алгоритм c помощью библиотеки OpenMP
3. Сравнить эфективность и время параллельного алгоритма на 1, 8 и 12 потоках, 
4. Узнать, как время исполнения зависит от размера сетки,`EPS` и выбранных функций

## Аппаратное обеспечение
- Процессор — **Apple M2**
- Оперативная память — **8 GB**
- Операционная система — **macOS Ventura 13.0**
- L1 data cache — **64 KB**
- core CPU — **8**
## Программное обеспечение
- OpenMP **4.5**
- GCC **6.1**

## Условия
### Обозначения
- $D$ — область задания функции, для простоты возьмем единичный квадрат. $D ={( x, y) ∈ D : 0 ≤ x, y ≤ 1 }$
- $N$ — размер сетки, т.н `size` в коде
- $k$ — количество итераций
- `BLOCK_SIZE` — размер блока
- `EPS` — допустимая разница между результатом приближения и истинным значением функции

### На каких данных проводились эксперименты:
- $N$ — **100, 300, 500, 1000, 2000**
- `BLOCK_SIZE` — **32, 64**
- `EPS` — **0.1, 0.01**
### Исследуемые функции для аппроксимации
1. $u(x, y) = 1000x^3 + 2000y^3$, $f(x, y) = 6000x + 12000y$
2. $u(x, y) = e^{xy}$, $f(x, y) = y^2 * e^{xy} + x^2 * e^{xy}$

#### Про выбор функции 
Были выбраны две краевые функции, чье количество итераций и, соответственно, время выполнения сильно отличаются. 
Важно знать, что результаты скорости вычислений не зависят от выбора функций. Об этом подробнее будет в выводе. 

## Результаты и вывод
Численные результаты эксперимента можно увидеть в [таблице](https://docs.google.com/spreadsheets/d/16Lk8SpY3h193Txz-zvt0MLYpKzV5tR5OnCibHUItRNs/edit?usp=sharing). Для замера времени вычисления было проведено 10 экспериментов и взято среднее. Зеленым помечены наилучшие значения среди исследуемых потоков. 

Можно сделать следующие выводы:
1. Используя алгоритм с распараллеливанием, разница в времени вычисления довольно существенная, если **N >= 300**
2. Выгоднее всего (в терминах времени) параллелить на 8 потоков. Также, на 12 потоках быстрее, чем на 1, но иногда медленнее, чем на 8. Самая очевидная и существенная причина этому - 8 ядер CPU на данной вычислительной машине. Другая же причина в том, что при распараллеливании программы на 12 и более потоков, дополнительные ресурсы тратятся на поддержку параллельной обработки, в частности, на переключение контекста процессора между потоками. Итог: распараллеливание на большое количество потоков не всегда приводит к хорошей производительности
3. При уменьшении `EPS` время выполнения будет дольше. Связано это с тем, что `EPS` задает нам точность вычислений, т.е алгоритм будет продолжать работать, пока изменения значений не станут меньше данного `EPS`
4. В ходе эксперимента было выявлено, что результаты скорости вычислений не зависят от выбора функций. Краевая функция задаёт начальное состояние сетки, что влияет только на количество итераций (а это количество у параллельного и последовательного алгоритма одинаковое), поэтому избирать функции по каким-то "особенным признакам" по типу непрерывности в каких-то отдельных точках не имеет смысла, если это не оговорено в целях эксперимента
